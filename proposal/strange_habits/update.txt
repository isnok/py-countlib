I read the comment (L. 514++) several times, and in the beginning, i took it for granted. Why would it ever make sense to overwrite
the counts of a counter the dict way?

But what i found out is fundamental: The Counter class is less of a Counter and more of a mMultiset.
You may agree, with this example:
Say you have a distributed service, and use counters for any kind of monitoring / event counting.
All the counts are collected at a central point, where they shall be merged into the global counter.
At this point dict.update makes total sense, even the name!!

Not only that, but also i was first startled by the presence of the subtract method. I implemented even an add method to complement it
because i thought it was missing. I did not realize for some time, that this was just the same as Counter.update!

Anyway i find that some integrity gets lost by this not-required forbidding of that efficient operation.
in favor of a seemingly semantically more correct version, that could just have been given a new name, count for example.
Becaouse that is, what Counter.update basically does, is it *counts* the iterable.
having subtract be the complement of that is not more (probably even less) confusing.

The collections module claims to be fast and efficient. This seems to be another exception from this rule.
Line 492 reveals to me the error in pythonic thinking. If you trust in users to read at least the api once before using
a new class, then there is no necessity to forbid these (update and fromkeys) at all.
Just extending the existing behaviour would also work, since nobody would have expected Counter.update to behave different
from dict.update if they had read about a count method the first time they got a glimpse of the api.
Also the update method would have been hidden nicely (in the source at least).
